// The basic calibration algorithm is based on 'An Algorithm for the In-Field Calibration of a MEMS IMU' written by Umar Qureshi and Farid Golnaragh

// Accel.cpp : This file contains the 'main' function. Program execution begins and ends there.


// Run program: Ctrl + F5 or Debug > Start Without Debugging menu
// Debug program: F5 or Debug > Start Debugging menu

// Tips for Getting Started: 
//   1. Use the Solution Explorer window to add/manage files
//   2. Use the Team Explorer window to connect to source control
//   3. Use the Output window to see build output and other messages
//   4. Use the Error List window to view errors
//   5. Go to Project > Add New Item to create new code files, or Project > Add Existing Item to add existing code files to the project
//   6. In the future, to open this project again, go to File > Open > Project and select the .sln file


// For acceleration calibration, we use gravity acceleration as reference, so we need static position data.
// To select steady data, we take the average of the magnitude of the angular velocity that is known to be at steady status: 'gyro_magnitude' function
// Then use the steady status data to obtain nine parameters: 'OnCalibration' function.
// The detailed information of the calibration algorithm of 'OnCalibration' and the 'CholeskyLDL' function inside is in the report.
// After obtaining nine parameters 'CaliPara', we can calibrate raw acceleration data 'psample_accel' and output calibrated acceleration data 'paftcali_accel': 'accel_calibration' function.
// For gyroscope calibration, we use average method to find the three biases of gyroscope: 'gyro_calibration' function 

// To calibrate by using this code, you need to have a data file generated by placing the IMU in several random static positions.
// And I would recommend you to start recording the data when it is static and keep a few seconds since it is easy for the gyroscope calibration. 

// You need to replace the data file location in the 'main' function;
//             modify the total number of lines of the data file 'N'; 
//             modify the number of lines for taking the average of gyroscope data, which is known at steady status 'gyro_ave_N'. 

#include "windows.h"
#include "stdlib.h"
#include "stdio.h"
#include "tchar.h"
#include <math.h>
#include <fstream>
#include <string>
#include <type_traits>
#include <cstdio>
#include <iostream>
using namespace std;



bool CholeskyLDL(float* pMtrx, float* pVect, float* pBuff, long N)
{
	float* pDiag, * pTmp0, * pTmp1, * pTmp2, * pTmpA, * pTmpB;
	float	Rtemp, Temp1;
	long	k, m;

	{
		pTmp0 = pDiag = pMtrx;
		pTmp2 = pMtrx + (N * (N + 1) / 2);

		(*pBuff) = 1.0 / (*pDiag);
		m = 1;
	}
	while (m < N)
	{
		pTmp0 += m;
		pDiag += (++m);

		Rtemp = 0.0;
		pTmp1 = pTmp0;	pTmpA = pBuff;
		while (pTmp1 < pDiag)
		{
			Temp1 = (*pTmp1) * (*pTmpA++);
			Rtemp += (*pTmp1) * Temp1;
			(*pTmp1++) = Temp1;
		}
		*pTmpA = 1.0 / ((*pDiag) - Rtemp);

		++pTmp1;	k = m;
		while (pTmp1 < pTmp2)
		{
			pTmpB = pTmp1;	pTmpA = pTmp0;
			{
				Rtemp = (*pTmpB++) * (*pTmpA++);
			}
			while (pTmpA < pDiag)
			{
				Rtemp += (*pTmpB++) * (*pTmpA++);
			}
			*pTmpB -= Rtemp;	pTmp1 += (++k);
		}
	}

	pDiag = pMtrx + 1;
	pTmp2 = pVect + N;
	pTmp1 = pVect;
	while (++pTmp1 < pTmp2)
	{
		Rtemp = 0.0;
		pTmp0 = pVect;
		while (pTmp0 < pTmp1)
		{
			Rtemp += (*pDiag++) * (*pTmp0++);
		}
		*pTmp1 -= Rtemp;	++pDiag;
	}
	pDiag = pBuff;
	pTmp0 = pVect;
	while (pTmp0 < pTmp2)
	{
		(*pTmp0++) *= (*pDiag++);
	}
	--pTmp1;	m = N;
	pDiag = pMtrx + (N * (N + 1) / 2 - 2);
	while (pVect < pTmp1)
	{
		Rtemp = 0.0;
		pTmpA = pDiag;	pDiag -= (m--);	k = m;
		for (pTmp0 = pTmp1; pTmp0 < pTmp2; ++pTmp0)
		{
			Rtemp += (*pTmpA) * (*pTmp0);	pTmpA += (++k);
		}
		*(--pTmp1) -= Rtemp;
	}

	return true;
}


void OnCalibration(long N, float* pTestData, float* pCaliPara)
{
	float	gxg = 1.0 * 1.0;

	//3 scale factors, 3 misalignment factors, 3 biases
	float& q11 = pCaliPara[0], & q12 = pCaliPara[1], & q13 = pCaliPara[2],
		& q22 = pCaliPara[3], & q23 = pCaliPara[4], & q33 = pCaliPara[5],
		& b_1 = pCaliPara[6], & b_2 = pCaliPara[7], & b_3 = pCaliPara[8];
	{
		q11 = 1;		q12 = 0.0;		q13 = 0.0;
		q22 = 1;		q23 = 0.0;
		q33 = 1;
		b_1 = 0.0;		b_2 = 0.0;		b_3 = 0.0;
	}

	long	k;
	float	Tmp_x1, Tmp_x2, Tmp_x3, Tmp_u1, Tmp_u2, Tmp_u3, ResErr;
	float	dFdq11, dFdq12, dFdq13, dFdq22, dFdq23, dFdq33, dFdb_1, dFdb_2, dFdb_3, Ferror;
	float	Matrix[45], Vector[9], Buffer[9];

	float* pData;
	float tempmax = 0.0;
	int count = 0;

	ResErr = 100.0;

	while (ResErr > 1.0e-20)
	{
		for (k = 0; k < 45; ++k) Matrix[k] = 0.0;
		for (k = 0; k < 9; ++k) Vector[k] = 0.0;

		pData = pTestData;
		for (k = 0; k < N; ++k)
		{
			Tmp_x1 = pData[0] - b_1;
			Tmp_x2 = pData[1] - b_2;
			Tmp_x3 = pData[2] - b_3;
			pData += 3;

			Tmp_u1 = q11 * Tmp_x1 + q12 * Tmp_x2 + q13 * Tmp_x3;
			Tmp_u2 = q22 * Tmp_x2 + q23 * Tmp_x3;
			Tmp_u3 = q33 * Tmp_x3;

			dFdq11 = Tmp_u1 * Tmp_x1;
			dFdq12 = Tmp_u1 * Tmp_x2;
			dFdq13 = Tmp_u1 * Tmp_x3;
			dFdq22 = Tmp_u2 * Tmp_x2;
			dFdq23 = Tmp_u2 * Tmp_x3;
			dFdq33 = Tmp_u3 * Tmp_x3;

			dFdb_1 = -(Tmp_u1 * q11);
			dFdb_2 = -(Tmp_u1 * q12 + Tmp_u2 * q22);
			dFdb_3 = -(Tmp_u1 * q13 + Tmp_u2 * q23 + Tmp_u3 * q33);

			Ferror = 0.5 * (gxg - (Tmp_u1 * Tmp_u1 + Tmp_u2 * Tmp_u2 + Tmp_u3 * Tmp_u3));

			
			if (fabs(Ferror) > 0.5)
			{
				count++;
			}
			else
			{
				tempmax = max(tempmax, fabs(Ferror));
				Matrix[0] += dFdq11 * dFdq11;
				Matrix[1] += dFdq11 * dFdq12;
				Matrix[2] += dFdq12 * dFdq12;
				Matrix[3] += dFdq11 * dFdq13;
				Matrix[4] += dFdq12 * dFdq13;
				Matrix[5] += dFdq13 * dFdq13;
				Matrix[6] += dFdq11 * dFdq22;
				Matrix[7] += dFdq12 * dFdq22;
				Matrix[8] += dFdq13 * dFdq22;
				Matrix[9] += dFdq22 * dFdq22;
				Matrix[10] += dFdq11 * dFdq23;
				Matrix[11] += dFdq12 * dFdq23;
				Matrix[12] += dFdq13 * dFdq23;
				Matrix[13] += dFdq22 * dFdq23;
				Matrix[14] += dFdq23 * dFdq23;
				Matrix[15] += dFdq11 * dFdq33;
				Matrix[16] += dFdq12 * dFdq33;
				Matrix[17] += dFdq13 * dFdq33;
				Matrix[18] += dFdq22 * dFdq33;
				Matrix[19] += dFdq23 * dFdq33;
				Matrix[20] += dFdq33 * dFdq33;
				Matrix[21] += dFdq11 * dFdb_1;
				Matrix[22] += dFdq12 * dFdb_1;
				Matrix[23] += dFdq13 * dFdb_1;
				Matrix[24] += dFdq22 * dFdb_1;
				Matrix[25] += dFdq23 * dFdb_1;
				Matrix[26] += dFdq33 * dFdb_1;
				Matrix[27] += dFdb_1 * dFdb_1;
				Matrix[28] += dFdq11 * dFdb_2;
				Matrix[29] += dFdq12 * dFdb_2;
				Matrix[30] += dFdq13 * dFdb_2;
				Matrix[31] += dFdq22 * dFdb_2;
				Matrix[32] += dFdq23 * dFdb_2;
				Matrix[33] += dFdq33 * dFdb_2;
				Matrix[34] += dFdb_1 * dFdb_2;
				Matrix[35] += dFdb_2 * dFdb_2;
				Matrix[36] += dFdq11 * dFdb_3;
				Matrix[37] += dFdq12 * dFdb_3;
				Matrix[38] += dFdq13 * dFdb_3;
				Matrix[39] += dFdq22 * dFdb_3;
				Matrix[40] += dFdq23 * dFdb_3;
				Matrix[41] += dFdq33 * dFdb_3;
				Matrix[42] += dFdb_1 * dFdb_3;
				Matrix[43] += dFdb_2 * dFdb_3;
				Matrix[44] += dFdb_3 * dFdb_3;

				Vector[0] += dFdq11 * Ferror;
				Vector[1] += dFdq12 * Ferror;
				Vector[2] += dFdq13 * Ferror;
				Vector[3] += dFdq22 * Ferror;
				Vector[4] += dFdq23 * Ferror;
				Vector[5] += dFdq33 * Ferror;
				Vector[6] += dFdb_1 * Ferror;
				Vector[7] += dFdb_2 * Ferror;
				Vector[8] += dFdb_3 * Ferror;
			}
		}
		CholeskyLDL(Matrix, Vector, Buffer, 9);

		ResErr = 0.0;
		for (k = 0; k < 9; ++k)
		{
			pCaliPara[k] += Vector[k];
			ResErr += Vector[k] * Vector[k];
		}
	}
}



void accel_calibration(long N, float* psample_accel, float* paftcali_accel, float CaliPara[9])
{
	int i;
	float	Tmp_x1, Tmp_x2, Tmp_x3, Tmp_u1, Tmp_u2, Tmp_u3;
	float* ptemp_aftcali_accel = paftcali_accel;

	for (i = 0; i < N; i++)
	{
		Tmp_x1 = psample_accel[0] - CaliPara[6];
		Tmp_x2 = psample_accel[1] - CaliPara[7];
		Tmp_x3 = psample_accel[2] - CaliPara[8];
		psample_accel += 3;

		Tmp_u1 = CaliPara[0] * Tmp_x1 + CaliPara[1] * Tmp_x2 + CaliPara[2] * Tmp_x3;
		Tmp_u2 = CaliPara[3] * Tmp_x2 + CaliPara[4] * Tmp_x3;
		Tmp_u3 = CaliPara[5] * Tmp_x3;

		*ptemp_aftcali_accel++ = Tmp_u1;
		*ptemp_aftcali_accel++ = Tmp_u2;
		*ptemp_aftcali_accel++ = Tmp_u3;
	}
} 

float gyro_magnitude(int M, int* psample_gyro)
{
	int k;
	float sum_mag = 0.0, ave_mag = 0.0;
	int* p_temp = psample_gyro;

	for (k = 0; k < M; k++)
	{
		sum_mag += sqrt(pow(*p_temp++, 2.0) + pow(*p_temp++, 2.0) + pow(*p_temp++, 2.0));
	}

	ave_mag = sum_mag / M;
	return ave_mag;
}


float gyro_calibration_each_axis(int M, int* psample_gyro)
{
	int k;
	float sum = 0.0, ave = 0.0;
	int* p_temp_each_axis = psample_gyro;

	for (k = 0; k < M; k++)
	{
		sum += *p_temp_each_axis;
		p_temp_each_axis += 3;
	}

	ave = sum / M;
	return ave;
}

void gyro_calibration(long N, long gyro_ave_N, int* psample_gyro, int* paftcali_gyro)
{
	float ave_gyro_x, ave_gyro_y, ave_gyro_z; //take average as bias on each axis
	int* ptempsample_gyro = psample_gyro;
	int* ptempcalibrating_gyro = psample_gyro;
	int* ptemp_aftcali_gyro = paftcali_gyro;
	int i;

	ave_gyro_x = gyro_calibration_each_axis(gyro_ave_N, ptempsample_gyro++);
	ave_gyro_y = gyro_calibration_each_axis(gyro_ave_N, ptempsample_gyro++);
	ave_gyro_z = gyro_calibration_each_axis(gyro_ave_N, ptempsample_gyro++);

	for (i = 0; i < N; i++)
	{
		*ptemp_aftcali_gyro++ = *ptempcalibrating_gyro++ - ave_gyro_x;
		*ptemp_aftcali_gyro++ = *ptempcalibrating_gyro++ - ave_gyro_y;
		*ptemp_aftcali_gyro++ = *ptempcalibrating_gyro++ - ave_gyro_z;

	}
}


int main()
{
	long N = 151610; //total number of lines of the data file 
	float CaliPara[9]; //nine parameters

	float* psample_accel = (float*)malloc(3 * N * sizeof(float)); //pointer for the accel data read directly from the log file
	int* psample_gyro = (int*)malloc(3 * N * sizeof(int)); //pointer for the gyro data read directly from the log file

	float* ptemp_accel = psample_accel;
	int* ptemp_gyro = psample_gyro;

	float* psteady_accel = (float*)malloc(3 * N * sizeof(float)); //pointer for the accel data at steady status
	int* psteady_gyro = (int*)malloc(3 * N * sizeof(int)); //pointer for the gyro data at steady status

	float* ptempsteady_accel = psteady_accel;
	int* ptempsteady_gyro = psteady_gyro;

	float* paftcali_accel = (float*)malloc(3 * N * sizeof(float)); //pointer for the calibrated accel data
	int* paftcali_gyro = (int*)malloc(3 * N * sizeof(int)); //pointer for the calibrated gyro data

	float gyro_ave_mag_steady;
	int count_notsteady = 0;
	int gyro_ave_N = 21000; //number of lines for taking the average of gyroscope data, known at steady status
	int* pgyro_cmp = psample_gyro;
	int i;
	

	std::fstream infile;
	//open the log text file containing recorded data, please change to your location path
	infile.open("C:\\Users\\xxxxx\\Desktop\\ELEC491\\calibration\\accel\\Accel\\datalog(1).log", std::ios::in); 
	std::string datetime, accel_x, accel_y, accel_z, gyro_x, gyro_y, gyro_z;

	while (getline(infile, datetime, ',')
		&& getline(infile, accel_x, ',')
		&& getline(infile, accel_y, ',')
		&& getline(infile, accel_z, ',')
		&& getline(infile, gyro_x, ',')
		&& getline(infile, gyro_y, ',')
		&& getline(infile, gyro_z, '\n'))
	{
		*ptemp_accel++ = std::stod(accel_x) / 1024;
		*ptemp_accel++ = std::stod(accel_y) / 1024;
		*ptemp_accel++ = std::stod(accel_z) / 1024;
		*ptemp_gyro++ = std::stoi(gyro_x);
		*ptemp_gyro++ = std::stoi(gyro_y);
		*ptemp_gyro++ = std::stoi(gyro_z);
	}
	
	//select no-motion status samples
	gyro_ave_mag_steady = gyro_magnitude(gyro_ave_N, psample_gyro);

	for(i = 0; i < N; i++)
	{
		//select data that has a difference with the average of the gyroscope data magnitude by less than 50
		if (fabs(gyro_magnitude(1, pgyro_cmp) - gyro_ave_mag_steady) > 50) 
		{
			count_notsteady++;
		}
		else
		{
			*ptempsteady_accel++ = psample_accel[i];
			*ptempsteady_gyro++ = psample_gyro[i];
		}
		pgyro_cmp += 3;
	}

	//With the steady acceleration data 'psteady_accel', we can obtain nine parameters
	OnCalibration(N, psteady_accel, CaliPara);

	//After obtaining nine parameters 'CaliPara', we can calibrate raw acceleration data 'psample_accel' and output calibrated acceleration data 'paftcali_accel'
	accel_calibration(N, psample_accel, paftcali_accel, CaliPara);

	//Calibrate raw gyroscope data 'psample_gyro' and output calibrated gyroscope data 'paftcali_gyro'
	gyro_calibration(N, gyro_ave_N, psample_gyro, paftcali_gyro);

	infile.close();
	free(psample_accel);
	free(psample_gyro);
	free(psteady_accel);
	free(psteady_gyro);
	return 0;
}






//Code for generating simulation data with preset nine parameters and 'main' to run it
/*
void TestData_Simu(long N, float* pTestData)
{
	float	g = 9.79;

	//preset nine parameters
	float	q11, q12, q13, q22, q23, q33, b_1, b_2, b_3;
	{
		q11 = 1.012;	q12 = -0.08;	q13 = 0.09;
		q22 = 1.008;	q23 = 0.06;		q33 = 0.97;
		b_1 = 0.065;	b_2 = -0.033;	b_3 = 0.09;
	}

	srand(745538);

	float	a11, a12, a13, a21, a22, a23, a31, a32, a33;
	float	Vct_x, Vct_y, Vct_z, Rtemp, CosTmp, SinTmp;
	float	Scale = 3.14159265358979323846264338328 / RAND_MAX;

	float* pData = pTestData;
	float* pDataEnd = pTestData + 3 * N;
	while (pData < pDataEnd)
	{
		Vct_x = Scale * rand();
		Vct_y = Scale * rand();
		Vct_z = Scale * rand();
		Rtemp = Vct_x * Vct_x + Vct_y * Vct_y + Vct_z * Vct_z;

		if (Rtemp < 9.869604401089358618834490999876)
		{
			Rtemp = sqrt(Rtemp);
			Vct_x /= Rtemp;
			Vct_y /= Rtemp;
			Vct_z /= Rtemp;

			CosTmp = cos(Rtemp);
			SinTmp = sin(Rtemp);

			//generate an orthogonal matrix
			a11 = CosTmp + (1.0 - CosTmp) * Vct_x * Vct_x;
			a12 = (1.0 - CosTmp) * Vct_x * Vct_y - SinTmp * Vct_z;
			a13 = (1.0 - CosTmp) * Vct_x * Vct_z + SinTmp * Vct_y;
			a21 = (1.0 - CosTmp) * Vct_y * Vct_x + SinTmp * Vct_z;
			a22 = CosTmp + (1.0 - CosTmp) * Vct_y * Vct_y;
			a23 = (1.0 - CosTmp) * Vct_y * Vct_z - SinTmp * Vct_x;
			a31 = (1.0 - CosTmp) * Vct_z * Vct_x - SinTmp * Vct_y;
			a32 = (1.0 - CosTmp) * Vct_z * Vct_y + SinTmp * Vct_x;
			a33 = CosTmp + (1.0 - CosTmp) * Vct_z * Vct_z;

			//generate measured data by adding undesired deviation
			*pData++ = g * (q11 * a13 + q12 * a23 + q13 * a33) + b_1;
			*pData++ = g * (q22 * a23 + q23 * a33) + b_2;
			*pData++ = g * (q33 * a33) + b_3;
		}
	}
}

int main(int argc, _TCHAR* argv[])
{

	long	N = 20;
	float	CaliPara[9];
	float	CaliParaInv[9];
	float* pTestData = (float*)malloc(3 * N * sizeof(float));


	TestData_Simu(N, pTestData);

	OnCalibration(N, pTestData, CaliPara);


	free(pTestData);
	return 0;
}

*/

